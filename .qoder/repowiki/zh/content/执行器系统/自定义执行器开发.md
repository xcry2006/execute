# 自定义执行器开发

<cite>
**本文档引用的文件**
- [src/lib.rs](file://src/lib.rs)
- [src/executor.rs](file://src/executor.rs)
- [src/thread_executor.rs](file://src/thread_executor.rs)
- [src/pool.rs](file://src/pool.rs)
- [src/config.rs](file://src/config.rs)
- [src/error.rs](file://src/error.rs)
- [src/execution_mode.rs](file://src/execution_mode.rs)
- [src/semaphore.rs](file://src/semaphore.rs)
- [examples/tokio_integration.rs](file://examples/tokio_integration.rs)
- [EXECUTOR_CUSTOM.md](file://EXECUTOR_CUSTOM.md)
- [README.md](file://README.md)
- [Cargo.toml](file://Cargo.toml)
- [tests/pool_tests.rs](file://tests/pool_tests.rs)
- [benches/command_pool_bench.rs](file://benches/command_pool_bench.rs)
</cite>

## 目录
1. [简介](#简介)
2. [项目结构](#项目结构)
3. [核心组件](#核心组件)
4. [架构总览](#架构总览)
5. [详细组件分析](#详细组件分析)
6. [依赖关系分析](#依赖关系分析)
7. [性能考量](#性能考量)
8. [故障排除指南](#故障排除指南)
9. [结论](#结论)
10. [附录](#附录)

## 简介
本指南面向希望为命令池系统开发自定义执行器的开发者，重点围绕 CommandExecutor trait 的实现展开，涵盖同步与异步运行时（如 tokio）的集成策略、执行器选择与并发控制、错误处理与资源管理最佳实践，以及调试与故障排除技巧。读者无需深入底层即可理解如何在现有框架上扩展新的执行器实现。

## 项目结构
该项目采用模块化组织，核心模块包括：
- 执行器接口与默认实现：executor.rs
- 线程模式执行器：thread_executor.rs
- 命令池与并发控制：pool.rs
- 配置与错误模型：config.rs、error.rs
- 执行模式与配置：execution_mode.rs
- 并发控制信号量：semaphore.rs
- 示例与文档：examples/tokio_integration.rs、EXECUTOR_CUSTOM.md、README.md
- 测试与基准：tests/pool_tests.rs、benches/command_pool_bench.rs
- 依赖声明：Cargo.toml

```mermaid
graph TB
subgraph "核心模块"
L["lib.rs<br/>导出公共 API"]
E["executor.rs<br/>CommandExecutor 接口与 StdCommandExecutor"]
TE["thread_executor.rs<br/>线程模式执行器"]
P["pool.rs<br/>命令池与并发控制"]
C["config.rs<br/>命令配置"]
ER["error.rs<br/>错误模型"]
EM["execution_mode.rs<br/>执行模式"]
S["semaphore.rs<br/>信号量"]
end
subgraph "示例与文档"
EX["examples/tokio_integration.rs<br/>Tokio 集成示例"]
DOC["EXECUTOR_CUSTOM.md<br/>自定义执行器指南"]
R["README.md<br/>项目说明"]
end
subgraph "测试与基准"
T["tests/pool_tests.rs<br/>单元测试"]
B["benches/command_pool_bench.rs<br/>基准测试"]
end
L --> E
L --> TE
L --> P
L --> C
L --> ER
L --> EM
L --> S
P --> E
P --> S
P --> EM
P --> C
P --> ER
EX --> E
EX --> P
DOC --> E
R --> L
T --> P
B --> P
```

图表来源
- [src/lib.rs](file://src/lib.rs#L1-L17)
- [src/executor.rs](file://src/executor.rs#L1-L100)
- [src/thread_executor.rs](file://src/thread_executor.rs#L1-L148)
- [src/pool.rs](file://src/pool.rs#L1-L296)
- [src/config.rs](file://src/config.rs#L1-L109)
- [src/error.rs](file://src/error.rs#L1-L18)
- [src/execution_mode.rs](file://src/execution_mode.rs#L1-L70)
- [src/semaphore.rs](file://src/semaphore.rs#L1-L53)
- [examples/tokio_integration.rs](file://examples/tokio_integration.rs#L1-L62)
- [EXECUTOR_CUSTOM.md](file://EXECUTOR_CUSTOM.md#L1-L228)
- [README.md](file://README.md#L1-L60)
- [tests/pool_tests.rs](file://tests/pool_tests.rs#L1-L90)
- [benches/command_pool_bench.rs](file://benches/command_pool_bench.rs#L1-L93)

章节来源
- [src/lib.rs](file://src/lib.rs#L1-L17)
- [README.md](file://README.md#L1-L60)

## 核心组件
- CommandExecutor trait：定义统一的命令执行接口，支持不同运行时实现（std::process、tokio、async-std 等）。默认实现 StdCommandExecutor 基于标准库同步执行。
- CommandPool：命令队列与执行器管理器，支持多线程与多进程两种模式，可注入自定义执行器并配合信号量进行并发限制。
- CommandConfig：封装命令程序名、参数、工作目录与超时配置。
- ExecuteError：统一的错误模型，覆盖 IO 错误、超时与子进程异常。
- ExecutionMode/ExecutionConfig：执行模式（线程/进程）与工作线程/进程数、并发限制等配置。
- Semaphore：基于 Mutex+Condvar 的简单计数信号量，用于限制同时执行的外部进程数量。
- 线程模式执行器：ThreadExecutor 与 ThreadModeExecutor，将任务包装为 ThreadTask 在线程池中执行，内部仍通过子进程执行外部命令。

章节来源
- [src/executor.rs](file://src/executor.rs#L1-L100)
- [src/pool.rs](file://src/pool.rs#L1-L296)
- [src/config.rs](file://src/config.rs#L1-L109)
- [src/error.rs](file://src/error.rs#L1-L18)
- [src/execution_mode.rs](file://src/execution_mode.rs#L1-L70)
- [src/semaphore.rs](file://src/semaphore.rs#L1-L53)
- [src/thread_executor.rs](file://src/thread_executor.rs#L1-L148)

## 架构总览
下图展示了命令池如何通过 CommandExecutor 接口与不同运行时集成，以及线程模式与进程模式的差异。

```mermaid
graph TB
CP["CommandPool<br/>命令池与执行器管理"]
CE["CommandExecutor<br/>执行器接口"]
STD["StdCommandExecutor<br/>标准库同步执行"]
TOKIO_EX["TokioWithTimeoutExecutor<br/>Tokio 异步执行器"]
SEM["Semaphore<br/>并发限制"]
CFG["CommandConfig<br/>命令配置"]
ERR["ExecuteError<br/>错误模型"]
CP --> CE
CE --> STD
CE --> TOKIO_EX
CP --> SEM
CP --> CFG
CP --> ERR
```

图表来源
- [src/pool.rs](file://src/pool.rs#L1-L296)
- [src/executor.rs](file://src/executor.rs#L1-L100)
- [examples/tokio_integration.rs](file://examples/tokio_integration.rs#L1-L62)
- [src/semaphore.rs](file://src/semaphore.rs#L1-L53)
- [src/config.rs](file://src/config.rs#L1-L109)
- [src/error.rs](file://src/error.rs#L1-L18)

## 详细组件分析

### CommandExecutor 接口与默认实现
- 接口职责：抽象命令执行，要求实现者提供同步 execute 方法，返回标准库 Output 或统一 ExecuteError。
- 默认实现 StdCommandExecutor：直接委托内部 execute_command 函数，使用 wait-timeout 在当前线程等待并处理超时，避免额外等待线程，提升性能。
- 内部 execute_command：启动子进程，重定向 stdout/stderr，按配置处理超时与子进程终止，返回标准输出与状态码。

```mermaid
classDiagram
class CommandExecutor {
+execute(config) Result<Output, ExecuteError>
}
class StdCommandExecutor {
+execute(config) Result<Output, ExecuteError>
}
class execute_command {
+execute_command(config) Result<Output, ExecuteError>
}
CommandExecutor <|.. StdCommandExecutor : "实现"
StdCommandExecutor --> execute_command : "调用"
```

图表来源
- [src/executor.rs](file://src/executor.rs#L1-L100)

章节来源
- [src/executor.rs](file://src/executor.rs#L1-L100)

### 线程模式执行器
- ThreadTask：定义可在线程池中执行的任务接口，要求实现 execute 返回 ExecuteError。
- ThreadExecutor：管理共享任务队列与工作线程，定期轮询并执行任务；默认工作线程数来自系统可用并行度。
- CommandTask：将 CommandConfig 包装为 ThreadTask，内部仍通过 execute_command 执行外部命令。
- ThreadModeExecutor：对外暴露 submit/start 接口，负责将队列中的任务提交给线程执行器。

```mermaid
classDiagram
class ThreadTask {
+execute() Result<(), ExecuteError>
}
class ThreadExecutor {
-workers : usize
-tasks : Arc<Mutex<Vec<Box<dyn ThreadTask>>>>
+new(workers)
+submit(task)
+start(interval)
+workers() usize
}
class CommandTask {
-config : CommandConfig
+new(config)
+execute() Result<(), ExecuteError>
}
class ThreadModeExecutor {
-executor : Arc<ThreadExecutor>
+new(workers)
+start(interval)
+submit(config)
}
ThreadTask <|.. CommandTask : "实现"
ThreadModeExecutor --> ThreadExecutor : "组合"
ThreadExecutor --> ThreadTask : "执行"
CommandTask --> execute_command : "调用"
```

图表来源
- [src/thread_executor.rs](file://src/thread_executor.rs#L1-L148)
- [src/executor.rs](file://src/executor.rs#L26-L70)

章节来源
- [src/thread_executor.rs](file://src/thread_executor.rs#L1-L148)

### 命令池与并发控制
- CommandPool：基于 Mutex<VecDeque> 的线程安全队列，支持多线程与多进程两种模式；可注入自定义执行器并配合信号量限制并发。
- 启动流程：根据 ExecutionConfig 决定模式；线程模式下启动线程执行器并将队列任务转发给线程执行器；进程模式下启动工作线程并调用 execute_task；支持固定工作线程数与并发限制两种启动方式。
- 并发限制：通过 Semaphore.acquire_guard 在执行前获取许可证，执行完成后自动释放，避免过多外部进程同时运行。

```mermaid
sequenceDiagram
participant Pool as "CommandPool"
participant Mode as "ExecutionMode"
participant TE as "ThreadModeExecutor"
participant W as "Worker Threads"
participant Exec as "CommandExecutor"
participant Sem as "Semaphore"
Pool->>Mode : "读取配置"
alt "Thread 模式"
Pool->>TE : "start(interval)"
TE->>W : "启动工作线程"
loop "轮询队列"
Pool->>TE : "submit(CommandTask)"
TE->>Exec : "execute(config)"
end
else "Process 模式"
Pool->>W : "启动工作线程"
loop "轮询队列"
Pool->>Sem : "acquire_guard()"
Pool->>Exec : "execute(config)"
Exec-->>Pool : "结果/错误"
Pool->>Sem : "Drop 释放许可证"
end
end
```

图表来源
- [src/pool.rs](file://src/pool.rs#L134-L288)
- [src/semaphore.rs](file://src/semaphore.rs#L1-L53)
- [src/thread_executor.rs](file://src/thread_executor.rs#L112-L147)

章节来源
- [src/pool.rs](file://src/pool.rs#L1-L296)
- [src/semaphore.rs](file://src/semaphore.rs#L1-L53)

### 异步运行时集成（Tokio）
- 示例实现 TokioWithTimeoutExecutor：在同步 trait execute 中创建 tokio Runtime 并使用 block_on 运行异步命令执行；支持超时控制与错误映射。
- 与命令池集成：通过 CommandPool 的 start_executor_with_executor/start_executor_with_executor_and_limit 系列方法注入自定义执行器，实现异步运行时下的同步接口适配。

```mermaid
sequenceDiagram
participant Client as "调用方"
participant Pool as "CommandPool"
participant Exec as "TokioWithTimeoutExecutor"
participant RT as "Tokio Runtime"
participant Cmd as "tokio : : process : : Command"
Client->>Pool : "start_executor_with_executor_and_limit(...)"
Client->>Pool : "push_task(config)"
loop "工作线程轮询"
Pool->>Exec : "execute(config)"
Exec->>RT : "block_on(async {...})"
Exec->>Cmd : "构建命令并执行"
Cmd-->>Exec : "Output 或错误"
Exec-->>Pool : "Result<Output, ExecuteError>"
end
```

图表来源
- [examples/tokio_integration.rs](file://examples/tokio_integration.rs#L1-L62)
- [src/pool.rs](file://src/pool.rs#L229-L288)

章节来源
- [examples/tokio_integration.rs](file://examples/tokio_integration.rs#L1-L62)
- [src/pool.rs](file://src/pool.rs#L229-L288)

### 执行器选择策略与性能考虑
- 同步 vs 异步：若使用异步运行时（如 tokio），需在同步 trait 中进行运行时适配（如 block_on）。建议复用全局运行时以减少创建成本。
- 并发限制：通过 Semaphore 控制同时执行的外部进程数量，避免系统资源耗尽；在 I/O 密集型任务中适当提高并发。
- 工作线程数：根据 CPU 核心数与任务类型调整；I/O 密集型可使用更多线程；CPU 密集型线程数接近核心数更合适。
- 超时与资源回收：使用 wait-timeout 在同一线程等待并处理超时，避免额外等待线程；超时后主动终止子进程并清理。

章节来源
- [src/executor.rs](file://src/executor.rs#L26-L70)
- [src/semaphore.rs](file://src/semaphore.rs#L1-L53)
- [EXECUTOR_CUSTOM.md](file://EXECUTOR_CUSTOM.md#L173-L180)

### 错误处理与资源管理最佳实践
- 错误模型：ExecuteError 统一处理 IO 错误、超时与子进程异常，便于上层统一处理。
- 资源管理：在超时场景主动终止子进程并等待其退出；使用信号量保证许可证正确释放；线程模式下通过 RAII 守卫自动释放。
- 配置健壮性：CommandConfig 支持工作目录与超时配置，建议为长时间运行命令设置合理超时。

章节来源
- [src/error.rs](file://src/error.rs#L1-L18)
- [src/executor.rs](file://src/executor.rs#L42-L70)
- [src/semaphore.rs](file://src/semaphore.rs#L45-L52)
- [src/config.rs](file://src/config.rs#L68-L87)

### 调试技巧与故障排除
- 日志与最小化复现：在自定义执行器中打印命令与参数，定位问题；使用短超时与简单命令快速验证集成。
- 并发问题排查：检查并发限制是否过低导致饥饿；确认信号量在异常路径也能释放。
- 超时与终止：确认超时后子进程被正确终止；避免僵尸进程占用资源。
- 测试与基准：参考单元测试与基准测试，验证队列行为与性能回归。

章节来源
- [tests/pool_tests.rs](file://tests/pool_tests.rs#L1-L90)
- [benches/command_pool_bench.rs](file://benches/command_pool_bench.rs#L1-L93)

## 依赖关系分析
- 外部依赖：thiserror 用于错误派生；crossbeam-queue 用于无锁队列变体；wait-timeout 用于子进程超时等待；tokio 作为可选异步运行时。
- 内部模块耦合：CommandPool 依赖 CommandExecutor、ExecutionConfig、Semaphore、CommandConfig、ExecuteError；线程模式执行器依赖 ThreadTask 与 execute_command。

```mermaid
graph LR
CP["CommandPool"] --> CE["CommandExecutor"]
CP --> EM["ExecutionConfig"]
CP --> S["Semaphore"]
CP --> C["CommandConfig"]
CP --> ER["ExecuteError"]
CE --> E["execute_command"]
TE["ThreadExecutor"] --> TT["ThreadTask"]
TE --> E
```

图表来源
- [src/pool.rs](file://src/pool.rs#L1-L296)
- [src/executor.rs](file://src/executor.rs#L1-L100)
- [src/thread_executor.rs](file://src/thread_executor.rs#L1-L148)
- [src/semaphore.rs](file://src/semaphore.rs#L1-L53)
- [src/config.rs](file://src/config.rs#L1-L109)
- [src/error.rs](file://src/error.rs#L1-L18)

章节来源
- [Cargo.toml](file://Cargo.toml#L1-L13)
- [src/pool.rs](file://src/pool.rs#L1-L296)

## 性能考量
- 避免额外等待线程：使用 wait-timeout 在当前线程等待子进程，减少线程开销。
- 并发限制：通过信号量限制外部进程数量，平衡吞吐与资源占用。
- 工作线程数：根据任务类型与硬件条件调整；I/O 密集型可适度增加线程数。
- 运行时适配：在同步 trait 中进行运行时适配时，尽量复用运行时实例，避免频繁创建销毁。

章节来源
- [src/executor.rs](file://src/executor.rs#L26-L70)
- [src/semaphore.rs](file://src/semaphore.rs#L1-L53)
- [EXECUTOR_CUSTOM.md](file://EXECUTOR_CUSTOM.md#L173-L180)

## 故障排除指南
- 命令未执行或卡死：检查超时配置与线程/进程模式；确认工作线程是否在轮询队列。
- 超时未生效：确认超时逻辑是否正确触发并终止子进程；检查错误映射是否为 ExecuteError::Timeout。
- 并发过高导致系统资源耗尽：启用并发限制并通过信号量控制外部进程数量。
- 异步运行时集成失败：确认在同步 trait 中正确使用 block_on；检查 tokio 特性是否启用。

章节来源
- [src/executor.rs](file://src/executor.rs#L42-L70)
- [src/pool.rs](file://src/pool.rs#L165-L210)
- [examples/tokio_integration.rs](file://examples/tokio_integration.rs#L21-L40)

## 结论
通过 CommandExecutor 接口，项目提供了对多运行时的可插拔支持。默认的同步实现与线程模式执行器满足大多数场景需求；对于异步运行时（如 tokio），可通过自定义执行器在同步接口中适配异步逻辑。结合并发限制与合理的线程/进程配置，可在保证稳定性的同时获得良好性能。建议在实际项目中结合自身运行时与任务特征选择合适的执行器与模式，并通过测试与基准验证效果。

## 附录
- 快速开始：参考 README 中的示例，了解基本用法与依赖声明。
- 自定义执行器完整示例：参考 EXECUTOR_CUSTOM.md，包含基础用法、工作线程数与并发限制的使用方式。
- 示例：Tokio 集成与超时控制，展示如何在命令池中使用自定义执行器。

章节来源
- [README.md](file://README.md#L15-L49)
- [EXECUTOR_CUSTOM.md](file://EXECUTOR_CUSTOM.md#L109-L155)
- [examples/tokio_integration.rs](file://examples/tokio_integration.rs#L42-L61)